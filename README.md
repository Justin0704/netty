# netty
netty - 学习

1、一个EventLoopGroup包含一个或多个EventLoop

2、一个EventLoop在他的生命周期内只和一个Thread绑定

3、所有由EventLoop处理的IO事件都将在它专有的Thread上被处理

4、一个Channel在他的生命周期内只注册于一个EventLoop

5、一个EventLoop可能会被分配给一个或多个Channel

TCP粘包和拆包

TCP是个“流”协议，所谓流，就是没有界限的一串数据。

TCP底层并不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行包的划分

所以在业务上认为，一个完整的包可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送

原因：
数据从发送方到接收方需要经过操作系统的缓冲区，而造成粘包和拆包的主要原因就在这个缓冲区上。

粘包可以理解为缓冲区数据堆积，导致多个请求数据粘在一起，而拆包可以理解为发送的数据大于缓冲区，进行拆分处理。

造成粘包和拆包的原因主要有以下三个：

1、应用程序write写入的字节大小大于套接口发送缓冲区大小

2、进行MSS大小的TCP分段

3、以太网帧的payload大于MTU进行IP分片

粘包和拆包的解决方法：

由于底层的TCP无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组的，这个问题只能通过上层的应用协议栈设计来解决，根据业界的主流协议的解决方案，可以归纳如下。

1、消息长度固定，累计读取到长度和为定长LEN的报文后，就认为读取到了一个完整的信息

2、将回车换行符作为消息结束符

3、将特殊的分隔符作为消息的结束标志，回车换行符就是一种特殊的结束分隔符

4、通过在消息头中定义长度字段来标识消息的总长度

Netty中的粘包和拆包解决方案：

1、固定长度的拆包器 FixedLengthFrameDecoder，每个应用层数据包的都拆分成都是固定长度的大小

2、行拆包器 LineBasedFrameDecoder，每个应用层数据包，都以换行符作为分隔符，进行分割拆分

3、分隔符拆包器 DelimiterBasedFrameDecoder，每个应用层数据包，都通过自定义的分隔符，进行分割拆分

4、基于数据包长度的拆包器 LengthFieldBasedFrameDecoder，将应用层数据包的长度，作为接收端应用层数据包的拆分依据。按照应用层数据包的大小，拆包。这个拆包器，有一个要求，就是应用层协议中包含数据包的长度

